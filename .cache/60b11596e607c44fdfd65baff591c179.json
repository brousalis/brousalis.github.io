{"dependencies":[{"name":"../sprites"},{"name":"../consts"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _sprites = require(\"../sprites\");\n\nvar _consts = require(\"../consts\");\n\nvar _consts2 = _interopRequireDefault(_consts);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Level = function Level(levelData, callback) {\n  this.levelData = [];\n  for (var i = 0; i < levelData.length; i++) {\n    this.levelData.push(Object.create(levelData[i]));\n  }\n  this.t = 0;\n  this.callback = callback;\n};\n\nLevel.prototype.step = function (dt) {\n  var idx = 0,\n      remove = [],\n      curShip = null;\n\n  // Update the current time offset\n  this.t += dt * 1000;\n\n  //   Start, End,  Gap, Type,   Override\n  // [ 0,     4000, 500, 'step', { x: 100 } ]\n  while ((curShip = this.levelData[idx]) && curShip[0] < this.t + 2000) {\n    // Check if we've passed the end time\n    if (this.t > curShip[1]) {\n      remove.push(curShip);\n    } else if (curShip[0] < this.t) {\n      // Get the enemy definition blueprint\n      var enemy = _sprites.enemies[curShip[3]],\n          override = curShip[4];\n\n      // Add a new enemy with the blueprint and override\n      this.board.add(new Enemy(enemy, override));\n\n      // Increment the start time by the gap\n      curShip[0] += curShip[2];\n    }\n    idx++;\n  }\n\n  // Remove any objects from the levelData that have passed\n  for (var i = 0, len = remove.length; i < len; i++) {\n    var remIdx = this.levelData.indexOf(remove[i]);\n    if (remIdx != -1) this.levelData.splice(remIdx, 1);\n  }\n\n  // If there are no more enemies on the board or in\n  // levelData, this level is done\n  if (this.levelData.length === 0 && this.board.cnt[_consts2.default.OBJECT_ENEMY] === 0) {\n    if (this.callback) this.callback();\n  }\n};\n\nLevel.prototype.draw = function (ctx) {};\n\nexports.default = Level;"},"hash":"160f176e4819b9ac384cc678ed88429c"}