{"dependencies":[],"generated":{"js":"\"use strict\";\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n\nvar Game = new function () {\n  var boards = [];\n\n  // Game Initialization\n  this.initialize = function (canvasElementId, sprite_data, callback) {\n    this.canvas = document.getElementById(canvasElementId);\n\n    this.playerOffset = 10;\n    this.canvasMultiplier = 1;\n    this.setupMobile();\n\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n\n    this.ctx = this.canvas.getContext && this.canvas.getContext('2d');\n    if (!this.ctx) {\n      return alert('Please upgrade your browser to play');\n    }\n\n    this.setupInput();\n\n    this.loop();\n\n    if (this.mobile) {\n      this.setBoard(4, new TouchControls());\n    }\n\n    SpriteSheet.load(sprite_data, callback);\n  };\n\n  // Handle Input\n  var KEY_CODES = { 37: 'left', 39: 'right', 32: 'fire' };\n  this.keys = {};\n\n  this.setupInput = function () {\n    window.addEventListener('keydown', function (e) {\n      if (KEY_CODES[e.keyCode]) {\n        Game.keys[KEY_CODES[e.keyCode]] = true;\n        e.preventDefault();\n      }\n    }, false);\n\n    window.addEventListener('keyup', function (e) {\n      if (KEY_CODES[e.keyCode]) {\n        Game.keys[KEY_CODES[e.keyCode]] = false;\n        e.preventDefault();\n      }\n    }, false);\n  };\n\n  var lastTime = new Date().getTime();\n  var maxTime = 1 / 30;\n  // Game Loop\n  this.loop = function () {\n    var curTime = new Date().getTime();\n    requestAnimationFrame(Game.loop);\n    var dt = (curTime - lastTime) / 1000;\n    if (dt > maxTime) {\n      dt = maxTime;\n    }\n\n    for (var i = 0, len = boards.length; i < len; i++) {\n      if (boards[i]) {\n        boards[i].step(dt);\n        boards[i].draw(Game.ctx);\n      }\n    }\n    lastTime = curTime;\n  };\n\n  // Change an active game board\n  this.setBoard = function (num, board) {\n    boards[num] = board;\n  };\n\n  this.setupMobile = function () {\n    var container = document.getElementById('container'),\n        hasTouch = !!('ontouchstart' in window),\n        w = window.innerWidth,\n        h = window.innerHeight;\n\n    if (hasTouch) {\n      this.mobile = true;\n    }\n\n    if (screen.width >= 1280 || !hasTouch) {\n      return false;\n    }\n\n    if (w > h) {\n      alert('Please rotate the device and then click OK');\n      w = window.innerWidth;\n      h = window.innerHeight;\n    }\n\n    container.style.height = h * 2 + 'px';\n    window.scrollTo(0, 1);\n\n    h = window.innerHeight + 2;\n    container.style.height = h + 'px';\n    container.style.width = w + 'px';\n    container.style.padding = 0;\n\n    if (h >= this.canvas.height * 1.75 || w >= this.canvas.height * 1.75) {\n      this.canvasMultiplier = 2;\n      this.canvas.width = w / 2;\n      this.canvas.height = h / 2;\n      this.canvas.style.width = w + 'px';\n      this.canvas.style.height = h + 'px';\n    } else {\n      this.canvas.width = w;\n      this.canvas.height = h;\n    }\n\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.left = '0px';\n    this.canvas.style.top = '0px';\n  };\n}();\n\nvar SpriteSheet = new function () {\n  this.map = {};\n\n  this.load = function (spriteData, callback) {\n    this.map = spriteData;\n    this.image = new Image();\n    this.image.onload = callback;\n    this.image.src = 'sprites.png';\n  };\n\n  this.draw = function (ctx, sprite, x, y, frame) {\n    var s = this.map[sprite];\n    if (!frame) frame = 0;\n    ctx.drawImage(this.image, s.sx + frame * s.w, s.sy, s.w, s.h, Math.floor(x), Math.floor(y), s.w, s.h);\n  };\n\n  return this;\n}();\n\nvar TitleScreen = function TitleScreen(title, subtitle, callback) {\n  var up = false;\n  this.step = function (dt) {\n    if (!Game.keys['fire']) up = true;\n    if (up && Game.keys['fire'] && callback) callback();\n  };\n\n  this.draw = function (ctx) {\n    ctx.fillStyle = '#FFFFFF';\n\n    ctx.font = 'bold 40px bangers';\n    var measure = ctx.measureText(title);\n    ctx.fillText(title, Game.width / 2 - measure.width / 2, Game.height / 2);\n\n    ctx.font = 'bold 20px bangers';\n    var measure2 = ctx.measureText(subtitle);\n    ctx.fillText(subtitle, Game.width / 2 - measure2.width / 2, Game.height / 2 + 40);\n  };\n};\n\nvar GameBoard = function GameBoard() {\n  var board = this;\n\n  // The current list of objects\n  this.objects = [];\n  this.cnt = {};\n\n  // Add a new object to the object list\n  this.add = function (obj) {\n    obj.board = this;\n    this.objects.push(obj);\n    this.cnt[obj.type] = (this.cnt[obj.type] || 0) + 1;\n    return obj;\n  };\n\n  // Mark an object for removal\n  this.remove = function (obj) {\n    var idx = this.removed.indexOf(obj);\n    if (idx == -1) {\n      this.removed.push(obj);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  // Reset the list of removed objects\n  this.resetRemoved = function () {\n    this.removed = [];\n  };\n\n  // Removed an objects marked for removal from the list\n  this.finalizeRemoved = function () {\n    for (var i = 0, len = this.removed.length; i < len; i++) {\n      var idx = this.objects.indexOf(this.removed[i]);\n      if (idx != -1) {\n        this.cnt[this.removed[i].type]--;\n        this.objects.splice(idx, 1);\n      }\n    }\n  };\n\n  // Call the same method on all current objects\n  this.iterate = function (funcName) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    for (var i = 0, len = this.objects.length; i < len; i++) {\n      var obj = this.objects[i];\n      obj[funcName].apply(obj, args);\n    }\n  };\n\n  // Find the first object for which func is true\n  this.detect = function (func) {\n    for (var i = 0, val = null, len = this.objects.length; i < len; i++) {\n      if (func.call(this.objects[i])) return this.objects[i];\n    }\n    return false;\n  };\n\n  // Call step on all objects and them delete\n  // any object that have been marked for removal\n  this.step = function (dt) {\n    this.resetRemoved();\n    this.iterate('step', dt);\n    this.finalizeRemoved();\n  };\n\n  // Draw all the objects\n  this.draw = function (ctx) {\n    this.iterate('draw', ctx);\n  };\n\n  // Check for a collision between the\n  // bounding rects of two objects\n  this.overlap = function (o1, o2) {\n    return !(o1.y + o1.h - 1 < o2.y || o1.y > o2.y + o2.h - 1 || o1.x + o1.w - 1 < o2.x || o1.x > o2.x + o2.w - 1);\n  };\n\n  // Find the first object that collides with obj\n  // match against an optional type\n  this.collide = function (obj, type) {\n    return this.detect(function () {\n      if (obj != this) {\n        var col = (!type || this.type & type) && board.overlap(obj, this);\n        return col ? this : false;\n      }\n    });\n  };\n};\n\nvar Sprite = function Sprite() {};\n\nSprite.prototype.setup = function (sprite, props) {\n  this.sprite = sprite;\n  this.merge(props);\n  this.frame = this.frame || 0;\n  this.w = SpriteSheet.map[sprite].w;\n  this.h = SpriteSheet.map[sprite].h;\n};\n\nSprite.prototype.merge = function (props) {\n  if (props) {\n    for (var prop in props) {\n      this[prop] = props[prop];\n    }\n  }\n};\n\nSprite.prototype.draw = function (ctx) {\n  SpriteSheet.draw(ctx, this.sprite, this.x, this.y, this.frame);\n};\n\nSprite.prototype.hit = function (damage) {\n  this.board.remove(this);\n};\n\nvar Level = function Level(levelData, callback) {\n  this.levelData = [];\n  for (var i = 0; i < levelData.length; i++) {\n    this.levelData.push(Object.create(levelData[i]));\n  }\n  this.t = 0;\n  this.callback = callback;\n};\n\nLevel.prototype.step = function (dt) {\n  var idx = 0,\n      remove = [],\n      curShip = null;\n\n  // Update the current time offset\n  this.t += dt * 1000;\n\n  //   Start, End,  Gap, Type,   Override\n  // [ 0,     4000, 500, 'step', { x: 100 } ]\n  while ((curShip = this.levelData[idx]) && curShip[0] < this.t + 2000) {\n    // Check if we've passed the end time\n    if (this.t > curShip[1]) {\n      remove.push(curShip);\n    } else if (curShip[0] < this.t) {\n      // Get the enemy definition blueprint\n      var enemy = enemies[curShip[3]],\n          override = curShip[4];\n\n      // Add a new enemy with the blueprint and override\n      this.board.add(new Enemy(enemy, override));\n\n      // Increment the start time by the gap\n      curShip[0] += curShip[2];\n    }\n    idx++;\n  }\n\n  // Remove any objects from the levelData that have passed\n  for (var i = 0, len = remove.length; i < len; i++) {\n    var remIdx = this.levelData.indexOf(remove[i]);\n    if (remIdx != -1) this.levelData.splice(remIdx, 1);\n  }\n\n  // If there are no more enemies on the board or in\n  // levelData, this level is done\n  if (this.levelData.length === 0 && this.board.cnt[OBJECT_ENEMY] === 0) {\n    if (this.callback) this.callback();\n  }\n};\n\nLevel.prototype.draw = function (ctx) {};\n\nvar TouchControls = function TouchControls() {\n  var gutterWidth = 10;\n  var unitWidth = Game.width / 5;\n  var blockWidth = unitWidth - gutterWidth;\n\n  this.drawSquare = function (ctx, x, y, txt, on) {\n    ctx.globalAlpha = on ? 0.9 : 0.6;\n    ctx.fillStyle = '#CCC';\n    ctx.fillRect(x, y, blockWidth, blockWidth);\n\n    ctx.fillStyle = '#FFF';\n    ctx.globalAlpha = 1.0;\n    ctx.font = 'bold ' + 3 * unitWidth / 4 + 'px arial';\n\n    var txtSize = ctx.measureText(txt);\n\n    ctx.fillText(txt, x + blockWidth / 2 - txtSize.width / 2, y + 3 * blockWidth / 4 + 5);\n  };\n\n  this.draw = function (ctx) {\n    ctx.save();\n\n    var yLoc = Game.height - unitWidth;\n    this.drawSquare(ctx, gutterWidth, yLoc, \"\\u25C0\", Game.keys['left']);\n    this.drawSquare(ctx, unitWidth + gutterWidth, yLoc, \"\\u25B6\", Game.keys['right']);\n    this.drawSquare(ctx, 4 * unitWidth, yLoc, 'A', Game.keys['fire']);\n\n    ctx.restore();\n  };\n\n  this.step = function (dt) {};\n\n  this.trackTouch = function (e) {\n    var touch, x;\n\n    e.preventDefault();\n    Game.keys['left'] = false;\n    Game.keys['right'] = false;\n    for (var i = 0; i < e.targetTouches.length; i++) {\n      touch = e.targetTouches[i];\n      x = touch.pageX / Game.canvasMultiplier - Game.canvas.offsetLeft;\n      if (x < unitWidth) {\n        Game.keys['left'] = true;\n      }\n      if (x > unitWidth && x < 2 * unitWidth) {\n        Game.keys['right'] = true;\n      }\n    }\n\n    if (e.type == 'touchstart' || e.type == 'touchend') {\n      for (i = 0; i < e.changedTouches.length; i++) {\n        touch = e.changedTouches[i];\n        x = touch.pageX / Game.canvasMultiplier - Game.canvas.offsetLeft;\n        if (x > 4 * unitWidth) {\n          Game.keys['fire'] = e.type == 'touchstart';\n        }\n      }\n    }\n  };\n\n  Game.canvas.addEventListener('touchstart', this.trackTouch, true);\n  Game.canvas.addEventListener('touchmove', this.trackTouch, true);\n  Game.canvas.addEventListener('touchend', this.trackTouch, true);\n\n  // For Android\n  Game.canvas.addEventListener('dblclick', function (e) {\n    e.preventDefault();\n  }, true);\n  Game.canvas.addEventListener('click', function (e) {\n    e.preventDefault();\n  }, true);\n\n  Game.playerOffset = unitWidth + 20;\n};\n\nvar GamePoints = function GamePoints() {\n  Game.points = 0;\n\n  var pointsLength = 8;\n\n  this.draw = function (ctx) {\n    ctx.save();\n    ctx.font = 'bold 18px arial';\n    ctx.fillStyle = '#FFFFFF';\n\n    var txt = '' + Game.points;\n    var i = pointsLength - txt.length,\n        zeros = '';\n    while (i-- > 0) {\n      zeros += '0';\n    }\n\n    ctx.fillText(zeros + txt, 10, 20);\n    ctx.restore();\n  };\n\n  this.step = function (dt) {};\n};\n\nvar sprites = {\n  ship: { sx: 0, sy: 0, w: 37, h: 42, frames: 1 },\n  missile: { sx: 0, sy: 30, w: 2, h: 10, frames: 1 },\n  enemy_purple: { sx: 37, sy: 0, w: 42, h: 43, frames: 1 },\n  enemy_bee: { sx: 79, sy: 0, w: 37, h: 43, frames: 1 },\n  enemy_ship: { sx: 116, sy: 0, w: 42, h: 43, frames: 1 },\n  enemy_circle: { sx: 158, sy: 0, w: 32, h: 33, frames: 1 },\n  explosion: { sx: 0, sy: 64, w: 64, h: 64, frames: 12 },\n  enemy_missile: { sx: 9, sy: 42, w: 3, h: 20, frame: 1 }\n};\n\nvar enemies = {\n  straight: {\n    x: 0,\n    y: -50,\n    sprite: 'enemy_ship',\n    health: 10,\n    E: 100\n  },\n  ltr: {\n    x: 0,\n    y: -100,\n    sprite: 'enemy_purple',\n    health: 10,\n    B: 75,\n    C: 1,\n    E: 100,\n    missiles: 2\n  },\n  circle: {\n    x: 250,\n    y: -50,\n    sprite: 'enemy_circle',\n    health: 10,\n    A: 0,\n    B: -100,\n    C: 1,\n    E: 20,\n    F: 100,\n    G: 1,\n    H: Math.PI / 2\n  },\n  wiggle: {\n    x: 100,\n    y: -50,\n    sprite: 'enemy_bee',\n    health: 20,\n    B: 50,\n    C: 4,\n    E: 100,\n    firePercentage: 0.001,\n    missiles: 2\n  },\n  step: {\n    x: 0,\n    y: -50,\n    sprite: 'enemy_circle',\n    health: 10,\n    B: 150,\n    C: 1.2,\n    E: 75\n  }\n};\n\nvar OBJECT_PLAYER = 1,\n    OBJECT_PLAYER_PROJECTILE = 2,\n    OBJECT_ENEMY = 4,\n    OBJECT_ENEMY_PROJECTILE = 8,\n    OBJECT_POWERUP = 16;\n\nvar startGame = function startGame() {\n  var ua = navigator.userAgent.toLowerCase();\n\n  // Only 1 row of stars\n  if (ua.match(/android/)) {\n    Game.setBoard(0, new Starfield(50, 0.6, 100, true));\n  } else {\n    Game.setBoard(0, new Starfield(20, 0.4, 100, true));\n    Game.setBoard(1, new Starfield(50, 0.6, 100));\n    Game.setBoard(2, new Starfield(100, 1.0, 50));\n  }\n  Game.setBoard(3, new TitleScreen('Alien Invasion', 'Press fire to start playing', playGame));\n};\n\nvar level1 = [\n// Start,   End, Gap,  Type,   Override\n[0, 4000, 500, 'step'], [6000, 13000, 800, 'ltr'], [10000, 16000, 400, 'circle'], [17800, 20000, 500, 'straight', { x: 50 }], [18200, 20000, 500, 'straight', { x: 90 }], [18200, 20000, 500, 'straight', { x: 10 }], [22000, 25000, 400, 'wiggle', { x: 150 }], [22000, 25000, 400, 'wiggle', { x: 100 }]];\n\nvar playGame = function playGame() {\n  var board = new GameBoard();\n  board.add(new PlayerShip());\n  board.add(new Level(level1, winGame));\n  Game.setBoard(3, board);\n  Game.setBoard(5, new GamePoints(0));\n};\n\nvar winGame = function winGame() {\n  Game.setBoard(3, new TitleScreen('You win!', 'Press fire to play again', playGame));\n};\n\nvar loseGame = function loseGame() {\n  Game.setBoard(3, new TitleScreen('You lose!', 'Press fire to play again', playGame));\n};\n\nvar Starfield = function Starfield(speed, opacity, numStars, clear) {\n  // Set up the offscreen canvas\n  var stars = document.createElement('canvas');\n  stars.width = Game.width;\n  stars.height = Game.height;\n  var starCtx = stars.getContext('2d');\n\n  var offset = 0;\n\n  // If the clear option is set,\n  // make the background black instead of transparent\n  if (clear) {\n    starCtx.fillStyle = '#000';\n    starCtx.fillRect(0, 0, stars.width, stars.height);\n  }\n\n  // Now draw a bunch of random 2 pixel\n  // rectangles onto the offscreen canvas\n  starCtx.fillStyle = '#FFF';\n  starCtx.globalAlpha = opacity;\n  for (var i = 0; i < numStars; i++) {\n    starCtx.fillRect(Math.floor(Math.random() * stars.width), Math.floor(Math.random() * stars.height), 2, 2);\n  }\n\n  // This method is called every frame\n  // to draw the starfield onto the canvas\n  this.draw = function (ctx) {\n    var intOffset = Math.floor(offset);\n    var remaining = stars.height - intOffset;\n\n    // Draw the top half of the starfield\n    if (intOffset > 0) {\n      ctx.drawImage(stars, 0, remaining, stars.width, intOffset, 0, 0, stars.width, intOffset);\n    }\n\n    // Draw the bottom half of the starfield\n    if (remaining > 0) {\n      ctx.drawImage(stars, 0, 0, stars.width, remaining, 0, intOffset, stars.width, remaining);\n    }\n  };\n\n  // This method is called to update\n  // the starfield\n  this.step = function (dt) {\n    offset += dt * speed;\n    offset = offset % stars.height;\n  };\n};\n\nvar PlayerShip = function PlayerShip() {\n  this.setup('ship', { vx: 0, reloadTime: 0.25, maxVel: 200 });\n\n  this.reload = this.reloadTime;\n  this.x = Game.width / 2 - this.w / 2;\n  this.y = Game.height - Game.playerOffset - this.h;\n\n  this.step = function (dt) {\n    if (Game.keys['left']) {\n      this.vx = -this.maxVel;\n    } else if (Game.keys['right']) {\n      this.vx = this.maxVel;\n    } else {\n      this.vx = 0;\n    }\n\n    this.x += this.vx * dt;\n\n    if (this.x < 0) {\n      this.x = 0;\n    } else if (this.x > Game.width - this.w) {\n      this.x = Game.width - this.w;\n    }\n\n    this.reload -= dt;\n    if (Game.keys['fire'] && this.reload < 0) {\n      Game.keys['fire'] = false;\n      this.reload = this.reloadTime;\n\n      this.board.add(new PlayerMissile(this.x, this.y + this.h / 2));\n      this.board.add(new PlayerMissile(this.x + this.w, this.y + this.h / 2));\n    }\n  };\n};\n\nPlayerShip.prototype = new Sprite();\nPlayerShip.prototype.type = OBJECT_PLAYER;\n\nPlayerShip.prototype.hit = function (damage) {\n  if (this.board.remove(this)) {\n    loseGame();\n  }\n};\n\nvar PlayerMissile = function PlayerMissile(x, y) {\n  this.setup('missile', { vy: -700, damage: 10 });\n  this.x = x - this.w / 2;\n  this.y = y - this.h;\n};\n\nPlayerMissile.prototype = new Sprite();\nPlayerMissile.prototype.type = OBJECT_PLAYER_PROJECTILE;\n\nPlayerMissile.prototype.step = function (dt) {\n  this.y += this.vy * dt;\n  var collision = this.board.collide(this, OBJECT_ENEMY);\n  if (collision) {\n    collision.hit(this.damage);\n    this.board.remove(this);\n  } else if (this.y < -this.h) {\n    this.board.remove(this);\n  }\n};\n\nvar Enemy = function Enemy(blueprint, override) {\n  this.merge(this.baseParameters);\n  this.setup(blueprint.sprite, blueprint);\n  this.merge(override);\n};\n\nEnemy.prototype = new Sprite();\nEnemy.prototype.type = OBJECT_ENEMY;\n\nEnemy.prototype.baseParameters = {\n  A: 0,\n  B: 0,\n  C: 0,\n  D: 0,\n  E: 0,\n  F: 0,\n  G: 0,\n  H: 0,\n  t: 0,\n  reloadTime: 0.75,\n  reload: 0\n};\n\nEnemy.prototype.step = function (dt) {\n  this.t += dt;\n\n  this.vx = this.A + this.B * Math.sin(this.C * this.t + this.D);\n  this.vy = this.E + this.F * Math.sin(this.G * this.t + this.H);\n\n  this.x += this.vx * dt;\n  this.y += this.vy * dt;\n\n  var collision = this.board.collide(this, OBJECT_PLAYER);\n  if (collision) {\n    collision.hit(this.damage);\n    this.board.remove(this);\n  }\n\n  if (Math.random() < 0.01 && this.reload <= 0) {\n    this.reload = this.reloadTime;\n    if (this.missiles == 2) {\n      this.board.add(new EnemyMissile(this.x + this.w - 2, this.y + this.h));\n      this.board.add(new EnemyMissile(this.x + 2, this.y + this.h));\n    } else {\n      this.board.add(new EnemyMissile(this.x + this.w / 2, this.y + this.h));\n    }\n  }\n  this.reload -= dt;\n\n  if (this.y > Game.height || this.x < -this.w || this.x > Game.width) {\n    this.board.remove(this);\n  }\n};\n\nEnemy.prototype.hit = function (damage) {\n  this.health -= damage;\n  if (this.health <= 0) {\n    if (this.board.remove(this)) {\n      Game.points += this.points || 100;\n      this.board.add(new Explosion(this.x + this.w / 2, this.y + this.h / 2));\n    }\n  }\n};\n\nvar EnemyMissile = function EnemyMissile(x, y) {\n  this.setup('enemy_missile', { vy: 200, damage: 10 });\n  this.x = x - this.w / 2;\n  this.y = y;\n};\n\nEnemyMissile.prototype = new Sprite();\nEnemyMissile.prototype.type = OBJECT_ENEMY_PROJECTILE;\n\nEnemyMissile.prototype.step = function (dt) {\n  this.y += this.vy * dt;\n  var collision = this.board.collide(this, OBJECT_PLAYER);\n  if (collision) {\n    collision.hit(this.damage);\n    this.board.remove(this);\n  } else if (this.y > Game.height) {\n    this.board.remove(this);\n  }\n};\n\nvar Explosion = function Explosion(centerX, centerY) {\n  this.setup('explosion', { frame: 0 });\n  this.x = centerX - this.w / 2;\n  this.y = centerY - this.h / 2;\n};\n\nExplosion.prototype = new Sprite();\n\nExplosion.prototype.step = function (dt) {\n  this.frame++;\n  if (this.frame >= 12) {\n    this.board.remove(this);\n  }\n};\n\nwindow.addEventListener('load', function () {\n  Game.initialize('game', sprites, startGame);\n});"},"hash":"130771111b1690135a25c0063446c184"}